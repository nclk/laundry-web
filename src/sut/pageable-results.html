<link rel="import" href="/lib/nclk/hoquet.html">
<link rel="import" href="/src/sut/paginator.html">

<template>
    <style>
    :host {
    }
    #log {
        background-color: #ccc;
        background-color: #333;
        padding: 15px;
        overflow: auto;
    }
    p.log-entry {
        margin: 0px;
        padding: 0px;
        color: #eee;
        font-family: monospace;
        overflow: hidden;
        word-wrap: break-word;
        size: 12pt;
    }
    p.log-entry.debug {
        color: #aaa;
    }
    p.log-entry.warn {
        color: #ff5;
    }
    #toolbar {
        margin: 0 0 5px 0;
    }
    #toolbar ul {
        list-style: none outside none;
        margin: 0; padding: 0;
    }
    #toolbar ul li {
        display: inline-block;
    }
    .scroller {
        background: linear-gradient(145deg, #47f, #7bf);
        background: linear-gradient(145deg, #f74, #fb7);
        background: linear-gradient(145deg, #fff, #ddf);
        color: #333;
    }
    #follow-item {
        float: right;
        margin: 8px 20px 0 0;
    }
    </style>
    <div>
        <div id="toolbar">
            <ul>
                </li>
                    <paper-button raised class="scroller" id="top">
                        Scroll to top
                    </paper-button>
                </li>
                </li>
                    <paper-button raised class="scroller" id="bottom">
                        Scroll to bottom
                    </paper-button>
                </li>
                <li>
                    <sut-paginator id="paginator"></sut-paginator>
                </li>

                <li id="follow-item">
                    <paper-checkbox id="follow">Follow</paper-checkbox>
                </li>
            </ul>
        </div>

        <div id="log"></div>
    </div>
</template>


<script>

(() => {

    class Checkpoints extends Nclk.Hoquet(HTMLElement) {

        constructor() {
            super();
            this.render();
            Object.defineProperties(this, {
                $log: {
                    value: this.shadowRoot.getElementById("log")
                },
                $follow: {
                    value: this.shadowRoot.getElementById("follow")
                },
                $top: {
                    value: this.shadowRoot.getElementById("top")
                },
                $bottom: {
                    value: this.shadowRoot.getElementById("bottom")
                },
                $paginator: {
                    value: this.shadowRoot.getElementById("paginator")
                }
            });

            this.currentOffset = 0;
            this.perPage = 500;

            // TODO: this is obviously a hack, but I still don't know how to
            // do it with plain CSS.
            window.addEventListener("resize", _ => this.resize());
            this.resize();

            this.$follow.addEventListener("change", e => {
                e.target.checked && this.scrollToBottom();
            });
            this.$top.addEventListener("click", e => this.scrollToTop());
            this.$bottom.addEventListener("click", e => this.scrollToBottom());

            this.$paginator.addEventListener(
                "page-changed", e => this.init(e.detail.page)
            );
        }

        scrollToBottom() {
            this.$log.scrollTop = this.$log.scrollHeight;
        }

        scrollToTop() {
            this.$follow.checked = false;
            this.$log.scrollTop = 0;
        }

        resize() {
            let w = window,
                d = document,
                e = d.documentElement,
                g = d.getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight || g.clientHeight;

            this.$log.style.height = `${parseInt(y * 0.7)}px`;
        }

        get href() { return this._href; }
        set href(href) {
            Object.defineProperty(this, "_href", {
                value: href
            });
        }

        init(page = 1) {
            this.$log.innerHTML = "";
            this.currentPage = page;
            this.currentOffset = 0 + ((page-1) * this.perPage);
            this.remaining = this.perPage;
            this.complete = false;
            this.$follow.checked = this.status === "running";
            this.poll();
        }

        get status() { return this._status ? this._status : "running"; }
        set status(status) {
            this._status = status;
        }

        poll() {

            if (this.complete)
                return;

            const url = `${
                this.href
            }&order=created&direction=asc&offset=${
                this.currentOffset
            }&page=${
                this.currentPage
            }&per-page=${this.remaining}`;

            const req = new Request(url);

            this.remaining && Utils.fetch(this, req, {
                method: "GET",
                credentials: "same-origin"
            }, resp => {
                throw resp;
            }, data => {
                // append entries to log entries page
                const len = data.length;
                this.remaining -= len;
                this.initPaginator(data);

                if (len || this.status === "running") {
                    this.currentOffset += len;
                    this.appendResults(data.results);

                    if (
                        this.remaining &&
                        ((this.currentOffset < data.count) ||
                            this.status === "running")
                    ) {
                        setTimeout(
                            _ => this.poll(),
                            data.results.length ? 500 : 1000
                        );
                    } else {
                        if (data.next && this.$follow.checked) {
                            this.init(data.next);
                        } else {
                            this.complete = true;
                            this.$follow.checked = false;
                            this.$follow.disabled = true;
                        }
                    }
                }
            });
        }

        replaceTag(tag) {
            return tagsToReplace[tag] || tag;
        }
        
        safe_tags_replace(str) {
            return str.replace(/[&<>]/g, this.replaceTag);
        }

        initPaginator(data) {
            const paginatorData = Object.assign({}, data);
            paginatorData["per-page"] = this.perPage;
            this.$paginator.init(paginatorData);
        }

        appendResults(results) {
            let lastStatus = this.status;
            results.forEach(entry => {
                const $result = document.createElement("p");
                $result.innerHTML = this.safe_tags_replace(entry.message);
                $result.classList.add("log-entry");
                $result.classList.add(entry.level);
                this.$log.appendChild($result);
                this.$follow.checked
                    && this.scrollToBottom();
                lastStatus = this.status;
            });
        }

    }

    window.Sut.Checkpoints = Checkpoints;
    window.customElements.define("sut-checkpoints", Checkpoints);

})()
</script>
