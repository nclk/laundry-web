<link rel="import" href="/lib/nclk/hoquet.html">
<!-- TODO: Is this needed?: -->
<link rel="import" href="/lib/nclk/format.html">
<link rel="import" href="/src/sut/paginator.html">

<link rel="import" href="/bower_components/paper-item/paper-item.html">
<link rel="import" href="/bower_components/paper-item/paper-item-body.html">
<link rel="import" href="/bower_components/paper-material/paper-material.html">
<link rel="import" href="/bower_components/iron-icon/iron-icon.html">
<link rel="import" href="/bower_components/iron-icons/iron-icons.html">
<link rel="import" href="/bower_components/iron-icons/maps-icons.html">
<link rel="import" href="/bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="/bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="/bower_components/paper-button/paper-button.html">

<template>
    <style>
    :host {
    }
    #log-container {
        background-color: #333;
    }
    #log {
        background-color: #ccc;
        background-color: #333;
        padding: 15px;
        overflow: auto;

        -ms-overflow-style: none;  // IE 10+
        overflow: -moz-scrollbars-none;  // Firefox
    }
    #log::-webkit-scrollbar {
        display: none;  // Safari and Chrome
    }
    p.log-entry {
        margin: 0px;
        padding: 0px;
        color: #eee;
        font-family: monospace;
        overflow: hidden;
        word-wrap: break-word;
        white-space: pre-wrap;
        size: 12pt;
    }
    p.log-entry.debug {
        color: #aaa;
    }
    p.log-entry.warn {
        color: #ff5;
    }
    p.log-entry.error {
        color: #f55;
    }
    p.log-entry.fatal {
        color: #f00;
        font-weight: bold;
    }
    #scroll-buttons {
        display: inline-block;
        margin: 0 0 5px 0;
    }
    #scroll-buttons ul {
        list-style: none outside none;
        margin: 0; padding: 0;
    }
    #scroll-buttons ul li {
        display: inline-block;
    }
    .scroller {
        background: linear-gradient(145deg, #47f, #7bf);
        background: linear-gradient(145deg, #f74, #fb7);
        background: linear-gradient(145deg, #fff, #ddf);
        color: #333;
    }
    #follow-item {
        float: left;
        margin: 9px 20px 0 20px;
    }
    #progress {
        margin: 0 10px 10px;
    }
    </style>

    <sut-paginator id="paginator">
        <div slot="before-page-controls" id="scroll-buttons">
            <ul>
                </li>
                    <paper-button raised class="scroller" id="top">
                        Scroll to top
                    </paper-button>
                </li>
                </li>
                    <paper-button raised class="scroller" id="bottom">
                        Scroll to bottom
                    </paper-button>
                </li>
            </ul>
        </div>
        <div slot="after-page-controls" id="follow-item">
            <paper-checkbox id="follow">FOLLOW</paper-checkbox>
        </div>
        <div slot="resultset" id="log-container">
            <div id="log"></div>
            <div id="progress-container">
                <paper-spinner-lite id="progress" active></paper-spinner-lite>
            </div>
        </div>
    </sut-paginator>
</template>

<script>

(() => {

    const tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };

    class LogEntries extends Nclk.Hoquet(HTMLElement) {

        constructor() {
            super();
            this.render();
            Object.defineProperties(this, {
                $log: {
                    value: this.shadowRoot.getElementById("log")
                },
                $follow: {
                    value: this.shadowRoot.getElementById("follow")
                },
                $followItem: {
                    value: this.shadowRoot.getElementById("follow-item")
                },
                $top: {
                    value: this.shadowRoot.getElementById("top")
                },
                $bottom: {
                    value: this.shadowRoot.getElementById("bottom")
                },
                $paginator: {
                    value: this.shadowRoot.getElementById("paginator")
                },
                $progress: {
                    value: this.shadowRoot.getElementById("progress")
                },
                $progressContainer: {
                    value: this.shadowRoot.getElementById("progress-container")
                }
            });

            this.currentOffset = 0;
            this.perPage = 500;

            // TODO: this is obviously a hack, but I still don't know how to
            // do it with plain CSS.
            window.addEventListener("resize", _ => this.resize());
            this.resize();
            // <\hack>

            this.$follow.addEventListener("change", e => {
                if (e.target.checked) {
                    this.scrollToBottom();
                }
            });
            this.$follow.checked = true;
            this.$top.addEventListener("click", e => this.scrollToTop());
            this.$bottom.addEventListener("click", e => this.scrollToBottom());

            this.$paginator.addEventListener(
                "page-changed", e => this.init(e.detail.page)
            );
        }

        progress(active) {
            this.$progress.active = active;
            this.$progressContainer.style.display = active
                ? "block"
                : "none";
        }

        scrollToBottom() {
            this.$log.scrollTop = this.$log.scrollHeight;
        }

        scrollToTop() {
            this.$follow.checked = false;
            this.$log.scrollTop = 0;
        }

        resize() {
            let w = window,
                d = document,
                e = d.documentElement,
                g = d.getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight || g.clientHeight;

            this.$log.style.height = `${parseInt(y * 0.7)}px`;
        }

        get href() { return this._href; }
        set href(href) {
            Object.defineProperty(this, "_href", {
                value: href
            });
        }

        init(page = 1) {
            if (this.status === "running") {
                if (this.$follow.checked) {
                }
            } else {
                this.stopFollowing();
            }
            this.$log.innerHTML = "";
            this.currentPage = page;
            this.currentOffset = 0 + ((page-1) * this.perPage);
            this.remaining = this.perPage;
            this.fetchPage();
        }

        get status() { return this._status ? this._status : "running"; }
        set status(status) {
            this._status = status;
        }

        stopFollowing() {
            this.$follow.checked = false;
            this.progress(false);
        }

        fetchPage() {

            const url = `${
                this.href
            }&order=created&direction=asc&offset=${
                this.currentOffset
            }&page=${
                this.currentPage
            }&per-page=${this.remaining}`;

            const req = new Request(url);

            Utils.fetch(this, req, {
                method: "GET",
                credentials: "same-origin"
            }, resp => {
                throw resp;
            }, data => {
                this.handleLogEntriesResultSet(data)
            });
        }

        handleLogEntriesResultSet(resultSet) {
            // append entries to log entries page
            const len = resultSet.length;
            this.remaining -= len;
            this.initPaginator(resultSet);

            console.log("hate", resultSet);

            if (len || this.status === "running") {
                this.currentOffset += len;
                this.appendResults(resultSet.results);

                if (
                    this.remaining &&
                    ((this.currentOffset < resultSet.count) ||
                        this.status === "running")
                ) {
                    clearTimeout(this.timeout);
                    this.timeout = setTimeout(_ => this.fetchPage(), len ? 500 : 2000);
                } else {
                    if (resultSet.next && this.$follow.checked) {
                        this.init(resultSet.next);
                    } else {
                        console.log("Tom", this.status, resultSet.next, this.$follow.checked);
                        this.stopFollowing();
                        this.$follow.disabled = true;
                        this.$followItem.style.display = "none";
                    }
                }
            }
        }

        replaceTag(tag) {
            return tagsToReplace[tag] || tag;
        }
        
        safe_tags_replace(str) {
            return str.replace(/[&<>]/g, this.replaceTag);
        }

        initPaginator(data) {
            const resultSet = Object.assign({}, data);
            resultSet["per-page"] = this.perPage;
            this.$paginator.resultSet = resultSet;
            if (this.$follow.checked)
                this.$paginator.disableUnreachableControls(true);
        }

        appendResults(results) {
            let lastStatus = this.status;
            results.forEach(entry => {
                //const message = entry.message.length > 255
                //    ? entry.message.substring(0, 255) + "..."
                //    : entry.message;
                //this.$log.value = [this.$log.value, message, "\n"].join("");
                const $result = document.createElement("p");
                $result.innerHTML = this.safe_tags_replace(entry.message);
                $result.classList.add("log-entry");
                $result.classList.add(entry.level);
                this.$log.appendChild($result);
                this.$follow.checked
                    && this.scrollToBottom();
                lastStatus = this.status;
            });
        }

    }

    window.Sut.LogEntries = LogEntries;
    window.customElements.define("sut-log-entries", LogEntries);

})()
</script>
